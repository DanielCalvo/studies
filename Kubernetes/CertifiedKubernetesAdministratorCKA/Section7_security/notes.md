### 111: Kubernetes Security primitives
- Two things to set up:
- Who can access the cluster?
- What can they do?

- Who can access:
- Defined by authentication mechanisms
- You can base user access on:
    - Files - Usernames and Passwords
    - Files - Usernames and Tokens
    - Certificates
    - External certification providers (such as LDAP)
    - Service accounts (for machines only)

- What can they do:
- Defined by authorization mechanisms.
- You can set this up with:
    - RBAC Auth (role based access controls)
    - ABAC Auth (atribute based access control)
    - Node Authorization
    - Webhook mode

- Communication between applications in the cluster:
    - By default, all pods can talk to all pods within the cluster.
    - You can restrict access between them by using network policies.

### 112: Authentication
- We have two types of users: Humans, such as admins and developers
- And service accounts, aka robots.

- Kubernetes does not manage user accounts natively. It relies on an external source for that, like a file or certificates or external auth service.

- You can however, create and manage service accounts through kubernetes with:
    - `kubectl create serviceaccount sa1`
    - `kubectl list serviceaccount`

- All user access is managed by the kube-apiserver (aka api server). It authenticates the request before processing it

- Ways that the kube-api server authenticates:
    - You can have a list of usernames and passwords on a static password file
    - You can have a list of usernames and tokens on a static file
    - You can authenticate using certificates
    - And you can connect to a third party for auth (such as LDAP)

- Users and passwords on file:
- For list of usernames and passwords on file, you can create them as a .csv (:o) on the api server and use that as login information:
```
password123,user1,u0001
password123,user2,u0002
password123,user3,u0003

```

- The list above can also have a fourth column for groups.

- You then pass this file to the kube-apiserver on start up: --basic-auth-file=userdetails.csv (if you set kube-api from scratch!)
- If you set it up using kube-adm, you have to change the pod definition for the kube-apiserver pod to contain this command like flag

- To then authenticate on the kube-apiserver using this type of auth, you have manually pass it by plaintext on a curl request (:ooo)
- `curl -v -k https://master-node-ip:6443/api/v1/pods -u "user1:password123"`

- Static token file:
    - `<big long token>,user10,u0010,group1`
    - `<big long token>,user10,u0012,group2`

- When starting kube-apisever, pass: --token-auth-file=user-details.csv
- You then pass the token on a curl request with --header "Authorization: Bearer <bigtokenstring>"

- Protip: Neither token on plaintext or users on plaintext are recommended to adding new users.
- Use Role Based Authentication for new users!

### 115: TLS Basics
- Symmetric Encryption: Data is encrypted and decrypted using the same key. Sender and receiver need to have the key, which means it has to be exchanged between sender & receiver.
- Someone sniffing the network would be able to get the message and the encryption key.

- Assymetric encryption: Uses private and public keys. SSH also uses this communication format.

- Generate CSR (Certificate Signing Request)
- Send it to the CA (Certificate Authority)
- CA signs the CSR and now you have an actual CRT (Certificate)

- CAs use public and private keys to sign certificates. The public key of all CAs is built into the web browser.
- The browser uses the CA's public key to validate that the certificate was generated by the CA themselves.

These are public CA's that let you validate public websites.
They are not private CA's that can let you validate sites inside your local network / organization

You can have your own private CA (some CA vendors offer a private solution)

Usually certificates that are public keys are named .pem or .crt.
Usually private keys are named .key or -key.pem.
Private keys have the word "key" in them usually, either as an extension or part of the file name.

### 116: TLS in Kubernetes.
- Three types of certificates:
    - Root certificates (from the CA)
    - Server certificates (from the server)
    - Client certificates (from your local)

- All interaction between the k8s master and nodes is encrypted.
- kubectl establishes a secure connection to talk to the kube-apiserver

- Server certificates for servers (master?)
- Client certificates for clients  (nodes? remote user with kubectl?)
(Follow up from Dani: Clear that up!)

- Server components:
    - kube-apiserver exposes a HTTPS service. It has:
    - apiserver.crt
    - apiserver.key
    - ETCD server also has etcdserver.crt and etcdserver.key
    - Kubelet server also has kubelet.crt and kubelet.key

Client components, the clients can be:
- Us, admins, connecting to the cluster through kubectl or the REST api. (admin.crt, admin.key)
- kube-scheduler talks to the kube-apiserver to find pods that require scheduling and then gets the apiserver to schedule the pods on the right worker nodes. As far as the kube-apiserver is concerned, the scheduler is just another client, so it also needs to validate it's identity (scheduler.key, scheduler.crt)
- kube-controller-manager (controller-manager.crt, controller-manager.key)
- kube-proxy (kube-proxy.crt, kube-proxy.key)
- The kube-apiserver is the only service that talks to the ETCD server, so as far as the ETCD server is concernted, the kube-apiserver is also a client.
- The kube-apiserver also talks to the kubelets. In both of these communications, it can use api-server.key and api-server.crt, or you can generate certificate pairs for each communication channel.

- Kubernetes requires you to have at least one CA to sign all of this!
- You can even have more than one, one for all the components in the cluster, and another one for ETCD and apiserver (or just ETCD)
- For now we'll just stick to one CA for everything.

### 117: TLS in Kubernetes: Certificate creation
- Let's get started with the CA certs:
    - Generate key: `openssl genrsa -out ca.key 2048`
    - Generate CSR: `openssl req -new -key ca.key -subj "/CN=KUBERNETES-CA" -out ca.csr`
    - Sign certificates: `openssl x509 -req -in ca.csr -signkey ca.key -out ca.crt`
    - Since this is for the CA, it's self signed with the own key from the CA.

- Now let's do it for the admins:
    - `openssl genrsa -out admin.key 2048`
    - `openssl req -new -key admin.key -subj "/CN=kube-admin/O=system:masters" -out admin.csr`
    - `openssl x509 -req -in admin.csr -CA ca.crt -CAkey ca.key -out admin.crt`

Using O=system:masters is important above as it defines the certificate as meant for an admin user

- When using kubectl, you can create a file named kube-config.yaml with kind: Config and configure your certificates in there.
- We'll look at kube-config.yaml later.

- Whenever you configure a server or a client with certificates, you also need to distribute/specify a copy of ca.crt.
- The certificate for the kube-apiserver requires a openssl.cnf file as it's referred to by a bunch of names
- Each kubelet service also requires it's own certificate, named after it's host machne (ex: node03)

### 118: View certificate details
- It's important to know how the cluster was set up. (The hard way or kubeadm).
- Both use different methods to manage certificates
- If you deploy it from scratch, you create all the certificates by yourself.
- In this example we'll look at a cluster provisioned by kubeadm.

- In an environment set up by kubeadm, you can find the certificates for the kube-api server in the pod definition under
- `/etc/kubernetes/manifests/kube-apiserver.yaml`

- To decode a certificate and view details:
- `openssl x509 -in /etc/kubernetes/pki/apiserver.crt -text -noout`

If kubernetes is broken for some reason and you can't use kubectl logs to see the logs, you have to go one later down and use docker to see the logs (docker logs mycontainer)

### 120: Practice test - view certificates
Q: Identify the certificate file used for the kube-api server
A:    
- `ps aux | grep kube-apiserver | grep crt | grep api`
- `/etc/kubernetes/pki/apiserver.crt`

Q: Identify the Certificate file used to authenticate kube-apiserver as a client to ETCD Server
A: `/etc/kubernetes/pki/apiserver-etcd-client.crt`

Q: Identify the key used to authenticate kubeapi-server to the kubelet server
A: `/etc/kubernetes/pki/apiserver-kubelet-client.crt`

Q: Identify the ETCD Server Certificate used to host ETCD server
A: `/etc/kubernetes/pki/etcd/server.crt`

Q: What is the Common Name (CN) configured on the Kube API Server Certificate?
A: `openssl x509 -in file-path.crt -text -noout`
A: `Subject: CN=kube-apiserver`

(There are a few questions here just like the above one. Just read common certificate fields)

Q: What is the Common Name (CN) configured on the ETCD Server certificate?
A: `openssl x509 -in server.crt -text -noout`

Q: How long, from the issued date, is the Kube-API Server Certificate valid for?
A: 1 year

(ca.crt is valid for 10 years)

Q: Kubectl suddenly stops responding to your commands. Check it out! Someone recently modified the /etc/kubernetes/manifests/etcd.yaml file
A: Changed cert path on etcd.yaml

Q: The kube-api server stopped again! Check it out. Inspect the kube-api server logs and identify the root cause and fix the issue.
A: 


### 121: Certificates API
- Kubernetes has an API call that can sign CSRs for us!
- We can create a kubernetes object named CertificateSigningRequest.
-  pacman is the package m
- Let's create all the things for a user named pacman is the package m Jane.
    - `openssl genrsa -out jane.key 2048`
    - `openssl req -new -key jane.key -subj "/CN=jane" -out jane.csr`

- See [./121_CSR.yaml](./121_CSR.yaml) for an example of a CertificateSigningRequest object (syntax might be a bit off, didn't test it)
    - `kubectl apply -f 121_CSR.yaml`
    - `kubectl get csr`
    - `kubectl certificate approve jane`
    - `kubectl get csr jane -o yaml #Certificate will be part of the output`

- All certificate related operations are carried out by the controller manager.

### 122: Certificate quiz:
Q: Create a CertificateSigningRequest object with the name akshay with the contents of the akshay.csr file
A:
```yaml
apiVersion: certificates.k8s.io/v1beta1
kind: CertificateSigningRequest
metadata:
  name: jane
spec:
  groups:
    - system:authenticated
  usages:
    - digital signature
    - key enciperhment
    - server auth
  request: | #cat akshay.csr | base64
    LS0tLS1CRUdJTiBDRVJUSUZJQ0FURSBSRVFVRVNULS0tLS0KTUlJQ1ZqQ0NBVDRDQVFBd0VURVBN
    QTBHQTFVRUF3d0dZV3R6YUdGNU1JSUJJakFOQmdrcWhraUc5dzBCQVFFRgpBQU9DQVE4QU1JSUJD
    Z0tDQVFFQXdWblFiRzV6cUpBcDNieFV6R2lkYkY2UHFVdG1YOUhlSUFaeFQyYy8vOW9JCmNQWHFh
    bHRRRFNnUUEvanhSN3NDZnl5a0VKQ2taQVZFc3ducDNLZkVoRHVjQTg2QVZ3VHFhZEFoOTVqdkxQ
    UlAKcjhHUzhGMXZFaE9LVzRIbzJLLzlEN1FuMktOdmg2bU03dEpPd2RsT0Z0TG8rTm9GaVF6bTJ6
    SGpLeUwvUFViSwpzL05oRXAyRitTV0ZLeHRpT3BZUVlKNTh0citrOTRDcmhtYmRCSmdxMm50Q2JO
    YzVlYXo4L0NMWllPVEIzZ0ZtCnRsdlBHN3QrVjZaZnJJdUF1Z1ZWd0dYSFNBbFRzQWM3cTNkOG0v
    ZWdtbXdyMjUxVkVBUnl3b2JOcVd5TTJJRVcKUUNNS1Flb3d1UW5kMVpHWTRaOEgwai9sZTFRbWZq
    WkRxZnRQTGxEYzd3SURBUUFCb0FBd0RRWUpLb1pJaHZjTgpBUUVMQlFBRGdnRUJBQUdzVjlhVGJ5
    Y0orbmY1VnJST1dqVzU0ZVJESnd3Rm4rRkVwZmlYZFBTcnVYTFdzUkR5ClJhQzVOTVBlSFpNNXFD
    akQvaFRxdFI5bVJiUDhURWMrRjRLa1NGYnVaako5TG5aR3dSeHV4T1VYNnJIUjNWSTgKSHhOa3Qz
    WnZONXR6MkJPLzZXaWw2UkVjbFpsN0ovNkZMUnZhSTUwM2pKUWlqSytSR0YzV201bXhLcGYxOGdw
    RwpzYzRVZE1oUVI1NG9vT1BVdnUwT2NJcVZlcS82SWw5R0M0MWVQcTVjd2tCbG9QdkkxQ0x3MHI3
    QjR2ZFVjU3hnCmFablZQa3BnT0dDMXZXTkJNNEtDU3p0dlJCQUNBd29FOG9RQk9CdWUyZGlvQzR1
    bmZFZXhLb1Y3TVRaZk1kL3gKdTZHakZxQzZwNk83RlZ2ZFJXNU45SkN5ajVUTTlaUjJmRVk9Ci0t
    LS0tRU5EIENFUlRJRklDQVRFIFJFUVVFU1QtLS0tLQo=
```
A: `kubectl apply -f akshay.yaml`

Q: What is the Condition of the newly created Certificate Signing Request object?
A: `kubectl get csr` (Pending)
   
Q: Approve the CSR Request
A: `kubectl certificate approve akshay`

Q: That doesn't look very right. Reject that request.
A: `kubectl certificate deny agent-smith`
   
Q: Delete the request:
A: `kubectl delete csr agent-smith`


### 123: KubeConfig
- By default, kubectl looks for a file with the path $HOME/.kube/config which will contain the adress of the cluster and your login credentials
- The config file has 3 sections: Clusters, Contexts and Users.
- Clusters: Has configs related to the different clusters you might have access to (dev, prod, gcloud, whatever)
- Users: The user accounts with which you have access to these clusters. These users might have different privileges on different clusters
- Contexts: Defines which user account will be used to acccess each cluster. ex: dev@google, admin@production and so on.

- The server specification (address:port) goes into the Clusters section.
- The keys and certificates go into the users section.
- You then create a context specifying to use certain credentials on a certain cluster.
- You can specify a default context on kubeconfig.

- Have a look at 107_kubeconfig.yaml for an example. It's pretty straightforward.

- You can use kubectl to view and modify the config file too.
- `kubectl config view`
- `kubectl config view --kubeconfig=my-custom-config`
- `kube config use-context prod-user@production` This will reflect on the config file

- You can update your config file using other variations of the kubectl command:
- `kubectl config -h`

- You can also specify a namespace under a context definition in config.
- You can have a path to a certificate for a cluster in the config, or you can have the certificate in base64 in the config.

### 124: Practice test - Kubeconfig
Q: Where is the default kubeconfig file located in the current environment?
A: /root/.kube/config

Q: I would like to use the dev-user to access test-cluster-1. Set the current context to the right one so I can do that.
A: Manually create the context on the ~/.kube/config file:
```yaml
- name: dev-user@test-cluster-1
  context:
    cluster: test-cluster-1
    user: dev-user
```   
A: Then run: `kubectl config use-context dev-user@test-cluster-1`

### 126 : API Groups
- Whatever operations we've done so far to the cluster, we've been interacting with the API server, one way or the other.
- For instance, to get the version of your cluster, you can:
- `curl https://kube-master:6433/version`
- To get a list of pods you can:
- `curl https://kube-master:6433/api/v1/pods`

- The Kubernetes API is grouped into multiple endpoints depending on their purpose:
    - (/metrics, healthz, /version, /api, /apis, /logs and so on)
- In this section, we focus on the APIs responsible for the cluster functionality, which are /api and /apis
    - Core API: /api
    - named API: /apis

- The core group is where all core functionality exists
    - (v1/namespaces, v1/pods, v1/rc, v1/events, v1/endpoints, v1/nodes, v1/secrets and a bunch of other endpoints)

- The named group /apis is slightly more organized (according to author) and moving forward all k8s functionality will be here.
    - (/apps, /extensions, /storage.k8s.io, /authentication.k8s.io, /certificates.k8s.io)

- Within apps you have:
    - /apps/v1/deployments
    - /apps/v1/replicasets
    - /apps/v1/statefulsets
- And a bunch more endpoints!

- Each resource (like /apis/apps/v1/deployments) has a set of actions associated with them (such as list, get, create, delete, update, watch)
- The API reference can tell you what the API group is for each object.

- You can also access your API to see the supported API groups:
- `curl http://localhost:6443 -k`
- `curl http://localhost:6443/apis -k | grep "name"`

- A note on using curl to directly access the API: You have to authenticate! So you'll probably have to do something like:
- curl http://localhost:6443 -k --key admin.key --cert admin.crt --cacert ca.crt

You can also do this: kubectl proxy
Which will start a proxy on 127.0.0.1:8001, using your certificates and config files to connect to the cluster for you.
You can then curl this proxy and it will be the same as curling your target cluster, but already authenticated and with proper permissions!

However, do note: kube proxy is NOT the same as kubectl proxy

In the next section, we can see how we use parts of the API and verbs to allow or deny access to users.

### 127: RBAC
- First of all, we create a role object. [./127_developer-role.yaml](./127_developer-role.yaml) You then apply the role:
- `kubectl apply -f 127_developer-role.yaml`
- A role has apiGroups, resources and verbs. These determine what actiosn you can take with which resources on the cluster
- When we have our role object set up, we need to create a role binding. [./127_devuser-developer-binding](./127_devuser-developer-binding)
- Do note that these apply to the default namespace.

- To view roles and role bindings:
    - `kubectl get roles`
    - `kubectl get rolebindings`
    - `kubectl describe role developer`
    - `kubectl describe rolebinding devuser-developer-binding`

- You can also use this:
    - `kubectl auth can-i create deployments`
    - `kubectl auth can-i delete nodes`

- That's pretty cool! It'll return a boolean saying if you can or can not execute the specified action
- You can even test an user's permission:
    - `kubectl auth can-i create deployments --as dev-user`
    - `kubectl auth can-i create pods --as dev-user`
    - `kubectl auth can-i create pods --as dev-user --namespace test`

- You can even go one level down and restrict someone's access to something with certain names. For instance, you could restrict a role to interact only with the pods named "blue" and "orange"
- See [./127_resource-names.yaml](./127_resource-names.yaml)


### 128: Practice test - RBAC
Q: Inspect the environment and identify the authorization modes configured on the cluster.
A: `cat kube-apiserver.yaml | grep auth`

Q: How many roles exist in the default namespace?
A: `kubectl get roles` 

Q: What are the resources the weave-net role in the kube-system namespce is given access to?
A: `kubectl describe role weave-net --namespace kube-system`

Q: Which account is the weave-net role assigned to it?
A: kubectl describe clusterrolebinding weave-net --namespace kube-system

Q: A user dev-user is created. User's details have been added to the kubeconfig file. Inspect the permissions granted to the user. Check if the user can list pods in the default namespace.
A: `kubectl auth can-i get pods --as=dev-user`

Q: Create the necessary roles and role bindings required for the dev-user to create, list and delete pods in the default namespace.
A:



### 129: Cluster Roles and Role Bindings
- There are Cluster Roles and Cluster Role bindings! Uh-oh!
- Roles and RoleBindings are namespaced, meaning they're created within namespaces.
- If you don't specify a namespace, they're created in the default namespace.
- Namespaces as we've been seeing until now, can isolate some resources, but not all of them!
- You can't divide nodes in namespaces and we've been seeing until now. Those are cluster wide or cluster scoped resources. They cannot be associated to any particular namespace.

- Resources are categorized as: Namespaced or Clusterscoped
    - Namespaced resources: pods, replicasets, jobs, services, secrets, configmaps, roles, rolebindings (the ones we've seen so far!)
    - Cluster scoped resources: nodes, PVs, clusterroles, clusterrolebindings, certificatesigningrequests, namespaces)

- To see the full list of what is namespaced and what is cluster scoped, do:
- `kubectl api-resources --namespaced=true`
- `kubectl api-resources --namespaced=false`

- You can use cluster roles to give users to things like nodes and persistent volumes.
    - See [./129_cluster-role.yaml](./129_cluster-role.yaml)for an example of a cluster role.
    - And [./129_cluster-role-binding](./129_cluster-role-binding) for an example of a binding.

- They're very similar to the namespaced roles and rolebindings.

114: Practive: Cluster roles and cluster role bindings
kubectl get clusterroles --all-namespaces
(Follow up from Dani: You skipped the cluster role binding practice session. Do it later if you're feeling like it)


### 131: Image security
- When you specify on a pod:
    - image:nginx
- Kubernetes actually interprets this as:
    - image: docker.io/nginx/nginx

- To pull an image from a private registry, first you have to create a secret with the login credentials for the registry:
```
kubectl create secret docker-registry regcred \
    --docker-server=private-registry.io \
    --docker-username=myuser \
    --docker-password=mypassword \
    --docker-email=myemail
```

### 132: Practice test - Image Security
Q: Create a secret object with the credentials required to access the registry
A:
```
kubectl create secret docker-registry private-reg-cred \
    --docker-server=myprivateregistry.com:5000 \
    --docker-username=dock_user \
    --docker-password=dock_password \
    --docker-email=dock_user@myprivateregistry.com
```

Q: Configure the deployment to use credentials from the new secret to pull images from the private registry
A: Inside deployment specs:
```yaml
    spec:
      imagePullSecrets:
      - name: private-reg-cred
      containers:
      - image: myprivateregistry.com:5000/nginx:alpine
        imagePullPolicy: IfNotPresent
        name: web
```


### 133: Security Contexts
- You can ask a pod to run as a certain user id. Check 117_seccontext_pod.yaml.
- This is supported to be set for all the containers in the pod, or you can set it on an individual container in the pod.
- Depends on which part of the spec you put it.
- Capabilities apparently allows you to give certain priviledges to the process running inside the pod, but not root rights.
- If you don't specify a user for a container (either during build or at launch for k8s) it'll run as root

118: Practice test, security policy.
Set the policy for the entire pod but for some reason it didn't get picked up. Tried to put it inside a container and it crashed.
(Follow up from Dani: If you re-do this with the user specified under a container only (not the entire pod) you should be able replicate the failure. Maybe your understanding of yaml isn't that good!)

###134: Practice test - Security Contexts
Q: What is the user used to execute the sleep process within the 'ubuntu-sleeper' pod?
A: `kubectl exec ubuntu-sleeper whoami`

Q: Edit the pod 'ubuntu-sleeper' to run the sleep process with user ID 1010.
A: Container Spec:
```yaml
spec:
  containers:
  - command:
    - sleep
    - "4800"
    image: ubuntu
    imagePullPolicy: Always
    name: ubuntu
    securityContext:
      runAsUser: 1010
```

Q: Update pod 'ubuntu-sleeper' to run as Root user and with the 'SYS_TIME' capability.
A: 
```yaml
spec:
  containers:
  - command:
    - sleep
    - "4800"
    image: ubuntu
    imagePullPolicy: Always
    name: ubuntu
    resources: {}
    securityContext:
      capabilities:
        add: ["SYS_TIME"]
```

Q: Now try to run the below command in the pod to set the date: date -s '19 APR 2012 11:14:00'
A: `kubectl exec -it ubuntu-sleeper -- date -s '19 APR 2012 11:14:00'`


### 135: Network Policy
- From a webserver, traffic coming from users is an Ingress traffic.
- Traffic leaving the cluster is of type egress.

- To recap in Kubernetes:
    - Each Pod has an ip address.
    - Each node has an ip address.
    - Each service has an ip address.

- By default, all pods on the cluster can reach each other through the Kubernetes virtual networks.
- k8s is configured by default with an "All Allow" rule

- Imagine you have this:

- Frontend <> API server <> Database.
    - Your frontend should not (and has no reason to) connect to your database directly. It has to go through your backend API first.
    - You can implement a network policy to allow traffic to the database only from the backend server.
    - A NetworkPolicy is another object in a k8s cluster.
    - You link a NetworkPolicy to one or more pods.

- We use labels and matchLabels to link pods to policies.
- Not all network solutions support network policies.

(Follow up from Dani: The sample yaml given on this one was very crappy. Research and redo the text exercises on lecture 120!)

### 136 Practice test - Network Policy:
Q: Create a network policy to allow traffic from the 'Internal' application only to the 'payroll-service' and 'db-service'
A: 
```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: internal-policy
  namespace: default
spec:
  podSelector:
    matchLabels:
      name: internal
  policyTypes:
  - Egress
  - Ingress
  ingress:
    - {}
  egress:
  - to:
    - podSelector:
        matchLabels:
          name: mysql
    ports:
    - protocol: TCP
      port: 3306

  - to:
    - podSelector:
        matchLabels:
          name: payroll
    ports:
    - protocol: TCP
      port: 8080
  ```
 